// scripts/extractRdanaPdfFields.cjs
// Run with: node scripts/extractRdanaPdfFields.cjs

// run 2

const { PDFDocument } = require('pdf-lib');
const fs = require('fs');
const path = require('path');

async function main() {
  const pdfPath = path.resolve(
    __dirname,
    '../pdf-templates/rdana-mdrrmo-fillable-complete.pdf', // or -v2 if you changed it
  );

  if (!fs.existsSync(pdfPath)) {
    console.error('‚ùå PDF not found at:', pdfPath);
    console.error('   Adjust the path in extractRdanaPdfFields.cjs if needed.');
    process.exit(1);
  }

  const pdfBytes = fs.readFileSync(pdfPath);
  const pdfDoc = await PDFDocument.load(pdfBytes);
  const form = pdfDoc.getForm();
  const fields = form.getFields();

  /** @typedef {'text' | 'checkbox' | 'radio' | 'other'} GroupKey */

  /** @type {Record<GroupKey, string[]>} */
  const groups = {
    text: [],
    checkbox: [],
    radio: [],
    other: [],
  };

  for (const field of fields) {
    const name = field.getName();
    const ctorName = field.constructor.name; // e.g. PDFTextField, PDFCheckBox, PDFRadioGroup

    /** @type {GroupKey} */
    let kind = 'other';

    switch (ctorName) {
      case 'PDFTextField':
        kind = 'text';
        break;
      case 'PDFCheckBox':
        kind = 'checkbox';
        break;
      case 'PDFRadioGroup':
        kind = 'radio';
        break;
      default:
        kind = 'other';
        break;
    }

    // üî• We keep the original getFields() order *within each kind*
    groups[kind].push(name);
  }

  // --------------------------------------------------
  // 1) Generate the .ts file (same as before)
  // --------------------------------------------------
  const outLines = [];

  outLines.push('// AUTO-GENERATED by scripts/extractRdanaPdfFields.cjs');
  outLines.push('// Do not edit by hand.');
  outLines.push('');
  outLines.push('export const RDANA_PDF_FIELDS = {');

  const emitArray = (label, values) => {
    outLines.push(`  ${label}: [`);
    for (const v of values) {
      outLines.push(`    '${v}',`);
    }
    outLines.push('  ],');
  };

  emitArray('texts', groups.text);
  emitArray('checkboxes', groups.checkbox);
  emitArray('radios', groups.radio);
  emitArray('others', groups.other);

  outLines.push('} as const;');
  outLines.push('');

  const tsOutPath = path.resolve(
    __dirname,
    '../src/pdf/rdanaPdfFields.generated.ts',
  );
  fs.mkdirSync(path.dirname(tsOutPath), { recursive: true });
  fs.writeFileSync(tsOutPath, outLines.join('\n'), 'utf8');

  // --------------------------------------------------
  // 2) NEW: Generate a JSON file for the merge script
  // --------------------------------------------------

  // Flatten into an array like:
  // [ { "name": "text_1uvac", "type": "text" }, ... ]
  const flat = [];

  /** @type {GroupKey[]} */
  const kinds = ['text', 'checkbox', 'radio', 'other'];

  for (const kind of kinds) {
    for (const name of groups[kind]) {
      flat.push({ name, type: kind });
    }
  }

  const jsonOutPath = path.resolve(__dirname, './json/rdana-fields.json');
  fs.writeFileSync(jsonOutPath, JSON.stringify(flat, null, 2), 'utf8');

  console.log('‚úÖ Extracted RDANA PDF fields (original order) to:');
  console.log('   TS:', tsOutPath);
  console.log('   JSON:', jsonOutPath);
  console.log('');
  console.log('Counts:', {
    texts: groups.text.length,
    checkboxes: groups.checkbox.length,
    radios: groups.radio.length,
    others: groups.other.length,
  });
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
